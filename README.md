# Random Maze

## 1. Обзор

"Лабиринт" — это клиент-серверное веб-приложение, реализующее многопользовательскую игру. Ключевая механика заключается в том, что команда на перемещение, отданная одним игроком, синхронно применяется ко всем игрокам на игровом поле.

**Технологический стек:**
*   **Бэкенд**: Python 3.7+ с использованием `aiohttp` для реализации асинхронного веб-сервера и WebSocket-коммуникации.
*   **Фронтенд**: Нативный JavaScript (ES6+), HTML5 Canvas для рендеринга игрового поля, CSS3 для стилизации интерфейса.

---

## 2. Руководство пользователя

### 2.1. Цель игры

Основная задача — довести своего персонажа до финишной клетки (желтый квадрат) быстрее, чем остальные участники.

### 2.2. Управление

Взаимодействие с игрой осуществляется с помощью клавиатуры (`WASD` или клавиши-стрелки). Каждое нажатие отправляет на сервер команду на перемещение, которая применяется глобально ко всем игрокам.

### 2.3. Игровые элементы

*   **Ловушки**: Специальные клетки на поле, при попадании на которые активируется один из двух эффектов:
    1.  `return_to_start`: Персонаж возвращается на свою стартовую позицию.
    2.  `swap_positions`: Координаты всех игроков случайным образом перемешиваются между ними.

### 2.4. Режимы игры

Администратор (игрок с именем `admin`) может переключать режимы игры.

*   **Без лимитов (Unlimited)**: Режим без ограничений на частоту отправки команд.
*   **5 слотов (Slots)**: У каждого игрока есть 5 "слотов" для ходов. Каждый ход расходует один слот, которые регенерируют с течением времени (1 слот в секунду).
*   **Пошаговый (Turn-Based)**: Стратегический режим, разделенный на две фазы:
    1.  **Фаза планирования**: Игроки формируют очередь команд (до 10). Клиент в реальном времени отображает прогнозируемый путь персонажа на основе текущей очереди.
    2.  **Фаза выполнения**: После того как все игроки подтвердят готовность (клавиша `Пробел`), сервер последовательно выполняет команды. Порядок выполнения: первая команда игрока А, первая команда игрока Б, ..., вторая команда игрока А, вторая команда игрока Б, и т.д. Очередность игроков определяется алфавитным порядком их имен.

---

## 3. Техническая документация

### 3.1. Архитектура системы

Проект построен на двухуровневой клиент-серверной архитектуре. Обмен данными в реальном времени осуществляется по протоколу WebSocket (эндпоинт `/ws`).

### 3.2. Бэкенд (`backend/server.py`)

*   **Основные компоненты**:
    *   **`Game` Class**: Singleton-класс, инкапсулирующий все состояние игры (координаты игроков, структура лабиринта, текущий режим). Управляет игровой логикой через методы `reset_game()`, `execute_global_move()` и др.
    *   **`Player` Class**: Структура данных для хранения состояния отдельного игрока (ID, координаты, цвет, имя, специфичные для режима атрибуты).

*   **Генерация лабиринта (`generate_maze`)**:
    *   Для генерации используется **алгоритм Крускала** со структурой данных "Система непересекающихся множеств" (Disjoint Set Union, DSU), что гарантирует создание идеального лабиринта (связного графа без циклов).
    *   На этапе постобработки удаляется 20% внутренних стен для увеличения количества путей и усложнения навигации.

*   **Логика движения и коллизий (`execute_global_move`)**:
    *   Функция реализует основную игровую механику.
    *   Используется модель "предложение-проверка":
        1. Для каждого игрока вычисляется предполагаемая новая позиция.
        2. Система проверяет наличие коллизий (попытка нескольких игроков занять одну и ту же клетку).
        3. Если на целевую клетку претендует более одного игрока, все они остаются на своих исходных позициях. В ином случае ход выполняется.

*   **WebSocket-обработчик (`websocket_handler`)**:
    *   Управляет жизненным циклом WebSocket-соединений.
    *   Принимает и десериализует JSON-сообщения от клиентов, вызывая соответствующие методы класса `Game`.
    *   Отправляет обновления всем клиентам через функции `broadcast_state()` (полное состояние игры) и `broadcast_event()` (одиночные события).

### 3.3. Фронтенд (`frontend/game.js`)

*   **Управление состоянием**:
    *   Глобальный объект `gameState` хранит локальную копию состояния игры, синхронизируемую с сервером при получении сообщения `gameState`.

*   **Движок рендеринга**:
    *   Вся графика отрисовывается на элементе `<canvas>` с использованием Canvas API.
    *   Основная функция `draw()` вызывается через `requestAnimationFrame` для обеспечения плавной отрисовки и вызывает дочерние функции для каждого слоя (лабиринт, ловушки, игроки, пути).

*   **Предсказание пути в пошаговом режиме**:
    *   Для снижения нагрузки на сервер, предсказание пути полностью выполняется на стороне клиента (`calculatePredictedPaths`).
    *   Функция локально симулирует выполнение всей очереди команд, в точности повторяя серверную логику движения и обработки коллизий.
    *   Результат (массив координат) передается в функцию `drawPredictedPaths` для отрисовки траектории на холсте.

### 3.4. Локальный запуск

1.  **Предварительные требования**:
    *   Python 3.7+
    *   `pip`

2.  **Установка**:
    ```bash
    # Клонировать репозиторий
    git clone <repository_url>
    cd <repository_directory>

    # Установить зависимости
    pip install aiohttp
    ```

3.  **Запуск сервера**:
    ```bash
    python backend/server.py
    ```
    Сервер будет доступен по адресу `http://0.0.0.0:8080`.

4.  **Подключение клиентов**:
    *   Откройте `http://localhost:8080` в браузере.
    *   Для тестирования многопользовательского режима используйте несколько вкладок или окон браузера в режиме инкогнито.
